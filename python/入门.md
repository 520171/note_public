# python入门
>* 注释：
>   * 单行注释：使用```#```进行单行注释
>   * 多行注释：使用```'''注释内容'''```或```"""注释内容"""```进行多行注释
>
>
>* 数据类型：
>   * Numbers(数字)：int、float、boolean(None和空字符串为False)、complex(复数)
>   * String(字符串)
>       1. 单引号字符串：```'字符串内容'```
>       2. 双引号字符串：```"字符串内容"```
>       3. 三引号字符串(原样输出)：```'''字符串内容'''```
>       4. 字符串前置r(```r'字符串'```)：可实现转义字符原样输出
>       5. str(变量)：该方法可将其他类型的变量强转成字符串类型
>       6. 格式化输出字符串(使用%s、%d、%f作为占位符顶替变量)：`````'xxx%s,%d,%f'%(变量1, 变量2, 变量3)`````
>       7. 使用占位符(%s, %d, %f)进行格式化输出的本质：调用str(), int(), float()方法将变量进行强转
>       8. 使用占位符(%s, %d, %f)进行格式化输出时可在%后添加整型数n表示与前面保持n个字符距离，在%f之间添加小数(```.```前表示与前方保持的字符距离，```.```后表示保留的小数长度)
>       9. format()方法：该方法是字符串的方法，用于字符串格式化，以```{}```作为占位符，将方法参数逐个传递给占位符组成新的字符串(eg：```'xsac{}dd{}'.format(变量, 变量)```)
>   * List(列表)
>       1. 结构：使用```[]```包裹，类似于其他语言的数组
>       2. 下标：从左向右由0开始递增，从右向左由-1开始递减
>       3. 字符串也是一个列表，他的每一个字符都是列表的成员,因此列表也可以使用```in```和```[]```运算符
>       4. 列表可使用```*```号，用于将列表的元素拷贝整数1份
>       5. 列表可使用```in```符号检验列表是否包含该元素
>       6. range()方法转list：```list(range())```
>       7. 字符出转range：```list(字符串)```
>       8. 删除列表中的元素（delete）：
>           * ```del 列表对象[index]```
>           * list.pop(index)：```list.pop(index)```，用于删除指定下标的元素，若无参数则删除最后一个元素并返回元素值
>           * list.remove(值)：删除第一个等于该值的元素
>           * list.clear()：清空列表
>       9. 向列表添加成员（create）：
>           * 列表对象.insert(index, 元素)：向指定下标位置插入新的元素，并将其他元素往右挤兑
>           * 列表对象.append(元素)：向列表末端插入元素
>           * 列表对象.extend(列表对象)：将参数列表追加到列表对象末端
>           * 列表对象+列表对象：将两个列表对象进行拼接，不改变原列表的结构
>   * Sets(集合ies，无序不重复)
>       1. 创建集合(创建空集合必须调用set()方法)：
>           * sets1 = set()
>           * set1 = {1}
>       2. 集合用于存放无需且不可重复的元素
>       3. 可通过 ```sets2 = set(list/tuple)```将列表或元组转换成集合，达到去重的效果
>       4. 集合的运算符(差集，并集，全集)
>           * 差集：```sets1 - sets2```
>           * 并集：```sets1 | sets2```
>           * 交集：```sets1 & sets2```
>           * 对称差集（求两个集合不同的元素）：```sets1 ^ sets2```
>       5. 增加数据：
>           * ```sets1.add(元素)```
>           * ```sets1.update(集合)```,将集合合并到sets1中
>       6. 删除元素：
>           * sets1.pop()：删除第一个元素
>           * sets1.remove(元素)：删除指定元素，不存在则报错
>           * sets1.discard(元素)：删除元素，不存在不报错
>           * sets1.clear()：清空集合
>       7. 修改集合的元素：增加+删除
>   * Tuple(元组)
>       1. 元组类似于列表，但元组的元素不可修改，包括元组的长度
>       2. 创建一个元组
>           * tuple1 = (obj, )
>           * tuple2 = (abj, obj2, obj3)
>           * tuple3 = tuple(list对象)
>       3. 元组的查询方式和列表基本一致
>   * Dictionar(字典)
>       1. 字典类似于java的map,由键值对组成，键是唯一的
>       2. 创建字典对象：
>           * dict1 = dict()
>           * dict1 = {}
>       3. 修改字典：添加key相同的键值对去覆盖已有的键值对```dict1[key] = value```
>       4. 向字典插值：dict1['key'] = value
>       5. 合并两个字典：```dict1.update(dict2)```，dict2会合并到dict1中并将dict2和dict1key相同的键值对进行覆盖
>       6. 查询字典：
>           * dict1.keys()：以列表的方式返回字典的key
>           * dict1.values()：以列表的方式返回字典的value
>           * dict1.items()：以列表的形式返回字典的key和value，列表的每一个元素都是元组，每个元组存key和value
>           * dict1.get(key,defalut)：根据key获取字典的value，没有则返回default
>       7. 删除字典：
>           * del dict1[key]：当key不存在则报错
>           * dict1.clear()：清空字典
>           * dict1.pop(key, default)：根据key删除键值对，并返回删除的键值对的value，没有则返回default
>
>
>* 获取变量的数据类型：
>   * type(变量名)，该方法返回变量类型
>   * isinstance(变量名, 变量类型(int/float))，当变量的类型和第二参数一致时返回true否则返回false
>
>
>* python标识符的命名规范：
>   * 见名知义
>   * 变量名单词之间使用```_```分割
>   * 类名所有单词的首字母大写
>   * 常量所有字母都是大写
>
>
>* 运算符：
>   * 扩展的算数运算符：
>       1. ```**```：a**b即求a的b次方
>       2. ```//```：整除
>       3. ```*```：字符串可以和整数相乘，结果为整数个字符串拼接
>   * 扩展的关系运算符：
>       1. ```==```：判断参与运算的两个对象的值是否相等，是返回true否则返回false;比较变量是否相等必须保证两个变量的类型是一致的
>       2. ```is```：判断参与运算的两个对象的地址是否一致(判断id())，是返回true否则返回false
>   * 逻辑运算符：
>       1. ```or```：或
>       2. ```and```：与
>       3. ```not```：非
>   * 三目运算(满足条件返回值1否则返回值2)：```a = 值1 if 条件 else 值2```
>   * 字符串运算符：
>       1. ```+```：字符串拼接符，拼接的两个对象必须都是字符串
>       2. ```*```：一边为数字，一边为字符串，将整数个字符串进行拼接
>       3. ```in```：如```字符串1 in 字符串2```，判断字符串2是否包含字符串1
>       4. ```not in```：如```字符串1 in 字符串2```，判断字符串2是否不包含字符串1
>       5. ```r```：如```r字符串```，无视转义字符直接输出
>       6. ```%```：如```字符串%(变量1, 变量2, ...)```，用于字符串格式化输出
>       7. ```[下标1:下标2:n3]```：如```字符串[n1:n2:n3]```，用于截取字符串或将字符串翻转
>           * n3：表示步长，正负决定方向，负数表示逆向(下标也必须一致)，正数表示正向(下标也必须一致)
>           * 下标：正向从左向右由0开始，反向从右向左由-1开始
>           * 截取下标：左闭右开，[下标1, 下标2)
>
>
>* 各种进制：
>   * 二进制：以```0b```开头
>   * 八进制：以```0o```开头
>   * 十六进制：以```0x```开头·
>   * 其他进制转十进制的方法：int(变量)
>   * 其他进制转二进制的方法：bin(变量)
>   * 其他进制转八进制的方法：oct(变量)
>   * 其他进制转十六进制的方法：hex(变量)
>
>
>* 装包和拆包：
>   * 装包和拆包类似于js的结构赋值
>   * 拆包：将一个可迭代的对象(列表，元组)拆分出来
>   * 装包：将多个元素装在一个list中
>   * 列子：
>       ```
>       # 装包，使用*将多余的元素存放在一个列表进行赋值
>       val1, *val2 = 1,2,3,4,5
>       val3, *val4 = [6,7,8,9]
>     
>       # 拆包，使用*将一个可迭代的对象结构出来
>       print(*val2)
>       ```
>
>
>* 流程控制语句：
>   * 分支语句(if)：
>       ```
>       # 分支控制的语句块必须tab缩进
>       # 用法1：
>           if 条件:
>               语句块
>       # 用法2：
>           if 条件:
>               语句块
>           else:
>               语句块
>       # 用法三：
>           if 条件1:
>               语句块
>           elif 条件2:
>               语句块
>           elif 条件3:
>               语句块
>           ...
>           else:
>               语句块
>       ```
>   * 循环语句:
>       1. for循环
>       ```
>       # for流程控制语句控制的语句块需要使用tab缩进
>       # 用法1：将列表逐个传递给变量
>           for 变量 in range(10):
>               语句块
>       '''
>         用法2：for配合else使用，当for自然结束时会自动执行else控制的语句块，
>         当使用break结束循环时则不会执行else语句块
>       '''
>           for 变量 in range(1, 11, 2):
>               语句块
>           else:
>               语句块
>       ```
>       2. while循环
>       ```
>       # for流程控制语句控制的语句块需要使用tab缩进
>       # 用法1：while后为循环条件，满足条件的则进入循环否则跳出循环
>       i = 0
>       while i <= 10:
>           语句块
>           i += 1
>       # 用法2：while配合else使用，当循环正常结束时会执行else语句块，否则不执行
>       while 条件:
>           语句块
>       else:
>           语句块
>       ```
>   * 控制循环语句(break, continue)：
>       1. break：用于跳出本层循环
>       2. continue：用于跳出本次循环
>   * pass语句：该语句仅用于占位，保证流程控制语句的语句块为空时可使用pass占位
>
>
>* 函数
>   * 结构：
>       ```
>       def funname(params):
>           pass
>           funbody
>           return xxx
>       ```
>   * 参数：
>       * 可变参数：
>           * 定义：
>               ```
>               # 可变参数会被装包成一个args元组
>               def funname(*args):
>                   pass
>               ```
>           * 当定义的函数的参数为装包时，执行时参数会被封装成元组类型。当需要定义不定长度的参数时可以定义装包作为形参且必须作为最后一个参数
>           * 当需要以列表，集合，元组的形式传入多个值给可变参数时，必须对列表，集合，元组进行拆包```funname(*list)```
>       * 关键字参数（属于可变参数）：
>           * 定义：类似于java的默认参数
>               ```
>               # 方式1
>               # 当存在多个默认参数时，如果需要跨默认参数赋值时funname(10, arg3=50)
>               def funname(arg, arg2=10, arg3=30)
>                   pass
>               
>               # 方式2,关键字参数会被装包成一个args字典
>               def funname(arg, **args):
>                   pass
>               ```
>           * 当希望以字典对象的形式向关键字参数```**args```传参时，需要使用```**```将字典拆成关键字参数
>   * 返回值：当函数返回值为多个值时，python会将多个返回值封装成一个元组对象并返回
>   * 内部函数：在函数内部定义函数
>   * 匿名函数：```lambda arg1, arg2, ... : 返回值```
>
>
>* 可变和不可变的数据类型：
>   * 不可变的数据类型：number, string, tuple
>   * 可变的数据类型：list, set, dict
>
>
>* 变量：
>   * 局部变量：形参，函数中定义的变量都是局部变量
>   * 全局变量：
>       1. 函数外声明的变量
>       2. 函数中可以直接访问全局变量，对于可变的数据类型可直接修改，对于不可变的数据类型不能直接修改
>       3. 函数中修改不可变的全局变量需要添加```global 全局变量名```
>   * 对于内部函数：
>       1. 内部函数访问全局变量的方式和普通函数一样
>       2. 内部函数可以直接访问外部函数的变量，对于可变的数据类型可直接修改，不可改变的数据类型不能直接修改
>       3. 内部函数修改外部函数的不可变的变量时需要添加```nonlocal 外部函数变量名```
>
>
>* 闭包：
>   * 闭包的特征：
>       1. 内部函数
>       2. 内部函数访问外部函数的变量
>       3. 内部函数名作为外部函数的返回值
>   * 闭包的作用：
>       1. 一般函数调用结束就会释放执行函数所需的空间，局部变量就会被释放，闭包可让函数信息继续保存
>   * py装饰器（函数作为参数，使用闭包）：
>       1. py装饰器使用到了闭包
>       2. 代码：
>           ```
>           # 定义装饰器方法（闭包）
>           # 装饰器方法的参数为被装饰的方法指针
>           def func_decorate(func):
>               pass
>               print("加载装饰前")
>               def func_inner(*args, **kargs):
>                   pass
>                   func(*args, **kargs) #执行原方法
>                   # 装饰内容...
>                   print('装饰内容...')
>               print("加载装饰后")
>               return func_inner # 返回内部函数指针
>          
>           # 创建原方法并添加装饰器方法注解
>           '''
>           当解释器执行
>           @func_decorate
>           ...
>           时内部的实际操作
>           执行func_decorate方法并传入原方法，并将方法的返回值（方法指针）重新传回给原方法对象：func_raw = func_decorate(func_raw)
>           '''
>           @func_decorate
>           def func_raw(*args, **kargs):
>               pass
>               print("原方法")
>               print(*args)
>               print(*kargs)
>           ```
>       3. 多层装饰器：（对于一个方法使用多个装饰器嵌套，离原方法最近的装饰器先起作用）
>           ```
>           # 装饰器1
>           def func_decorate1(func):
>               pass
>               print('开始加载装饰器1')
>               def func_inner(*args, **kargs):
>                   pass
>                   func(*args, **kargs)
>                   print('安装：', end='')
>                   print(*args)
>               print('完成加载装饰器1')
>               return func_inner
>           # 装饰器2
>           def func_decorate2(func):
>               pass
>               print('开始加载装饰器2')
>               def func_inner(*args, **kargs):
>                   pass
>                   func(*args, **kargs)
>                   print('安装：', end='')
>                   print(*args)
>               print('完成加载装饰器2')
>               return func_inner
>           # 原方法
>           @func_decorate2
>           @func_decorate1
>           def func_raw(*args, **kargs):
>               pass
>               print('啥也没有')
>           ```
>       4. 带参数的装饰器(内部函数再嵌套一个内部函数)：
>           ```
>           '''
>               装饰器有三层嵌套函数
>               第一层参数：用于装饰器传参
>               第二层参数：用于传递原方法指针
>               第三次参数：用于传递原方法的参数
>           '''
>           def func_decorate(arg):
>               pass
>               def func_inner1(func):
>                   pass
>                   def func_inner2(*args, **kargs):
>                       pass
>                       func(*args, **kargs)
>                       print('装饰器的参数是：{}'.format(arg))
>                   return func_inner2
>               return func_inner1
>          
>           @func_decorate('红火火恍恍惚惚')
>           def func_raw(*args, **kargs):
>               pass
>               print('原方法的参数是：', end='')
>               print(*args)
>           ```
>          
>
>* 魔术方法：
>   * 格式：```__魔术方法名__()```
>
>
>* with as 结构
>   * 结构：
>       ```
>       with 对象 as 引用:
>           pass
>           语句块
>       ```
>   * 要求：
>       * 对象必须包含两个魔术方法：
>           * ```__enter__(self)```：当with as执行时，回调对象的__enter__(self)方法，并把方法的返回值传递给引用
>           * ```__exit__(self)```：当整个with as语句块执行完后会自动调用对象的__exit__(self)方法
>
>
